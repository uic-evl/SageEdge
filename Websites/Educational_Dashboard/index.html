<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pedestrian Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { background: #191f59; color: white; font-family: sans-serif; padding: 20px; }
    .card { background: white; color: black; border-radius: 12px; padding: 15px; margin-bottom: 10px; margin-top: 10px;}
    .grid { display: grid; gap: 16px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); }
    
    .time-toggle {
      display: inline-flex;
      align-items: center;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      background: #f5f5f5;
      padding: 4px;
      gap: 4px;
      margin-right: 10px;
    }
    
    .time-toggle button {
      height: 32px;
      padding: 0 12px;
      font-size: 20px;
      border: none;
      background: transparent;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .time-toggle button:hover {
      background: #e0e0e0;
    }
    
    .time-toggle button.active {
      background: #0879d6;
      color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    
    .controls-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    select, button {
      padding: 6px 12px;
      font-size: 20px;
      border-radius: 6px;
      border: 1px solid #ccc;
    }
    
    .nav-button {
      background: #0879d6;
      color: white;
      border: none;
      cursor: pointer;
      min-width: 40px;
    }
    
    /* loading screen */
    .nav-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .nav-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      z-index: 10;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #e0e0e0;
      border-top: 5px solid #0879d6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      margin-top: 20px;
      font-size: 18px;
      color: #333;
      font-weight: bold;
    }

  </style>
</head>
<body>

  <div class="card">
    <p style="font-size: 30px; font-weight: bold; "> EVL Live üî¥ Directional Flow</p>
    <p style="font-size: 30px;">Smile and keep walking! üö∂‚Äç‚ôÄÔ∏è You're officially part of the graph! üìä The EVL Vision Team is exploring edge computing using AI to track people walking left and right. What you see here is your walk visualized.</p>

    <div class="controls-row">
      <select id="monthSelect" onchange="handleChange()"></select>
      <select id="daySelect" onchange="handleDayChange()" style="display: none;"></select>
      <select id="hourSelect" onchange="handleHourChange()" style="display: none;"></select>
      
      <button class="nav-button" onclick="prevPeriod()" id="prevBtn" style="display: none;">‚Üê</button>
      <span id="periodInfo"></span>
      <button class="nav-button" onclick="nextPeriod()" id="nextBtn" style="display: none;">‚Üí</button>
      
      <div style="flex: 1;"></div>
      
      <div class="time-toggle">
        <button onclick="changeGranularity('minute')" id="btn-minute">Minute</button>
        <button onclick="changeGranularity('hour')" id="btn-hour">Hour</button>
        <button onclick="changeGranularity('week')" id="btn-week">Week</button>
        <button onclick="changeGranularity('month')" class="active" id="btn-month">Month</button>
      </div>
    </div>

    <div id="chart-container" style="position: relative; height: 500px;">
      <canvas id="lineChart"></canvas>
    </div>

    <div id="custom-tooltip" style="margin-top: 10px; background: #f8f9fa; padding: 5px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
  </div>

  <script>
    let data = [], filteredData = [], selectedMonth = "All Data", selectedDay = null, selectedHour = null
    let granularity = "month", currentPeriodIndex = 0, lineChart

    const months = ['All Data','January','February','March','April','May','June','July','August','September','October','November','December']
    
    function showLoadingScreen() {
      const chartContainer = document.getElementById('chart-container')
      const overlay = document.createElement('div')
      overlay.id = 'loading-overlay'
      overlay.className = 'loading-overlay'
      overlay.innerHTML = `
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading data...</div>
      `
      chartContainer.appendChild(overlay)
    }

    function hideLoadingScreen() {
      const overlay = document.getElementById('loading-overlay')
      if (overlay) {
        overlay.remove()
      }
    }

    window.onload = () => {
      const monthSelect = document.getElementById("monthSelect")
      months.forEach(m => {
        const opt = document.createElement("option")
        opt.text = m
        monthSelect.add(opt)
      })

      updateDataAnalysis()

      // loading screen appears until data is fetched and chart rendered
      showLoadingScreen()

      fetch("https://sage.evl.uic.edu/api/get_viz_data")
        .then(res => res.json())
        .then(json => {
          

          // console.log('Full API response:', json)
          // console.log('json[0]:', json[0])
          // console.log('json[1]:', json[1])
          
          const apiData = json[1].data
          
          data = apiData.map(entry => {
            const dateObj = new Date(entry.Date)
            const [hours, minutes] = entry.Time.split(':')

            return {
              date: entry.Date.trim(),
              time: entry.Time,
              hour: parseInt(hours),
              minute: parseInt(minutes),
              displayDate: dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
              displayTime: entry.Time,
              left: entry.direction_left,
              right: entry.direction_right,
              cpu_temp: entry.CPU_temp,
              cpu_usage: entry.CPU_usage,
            }
          })
          
          // Set default month to current month
          const now = new Date()
          const currentMonthName = months[now.getMonth() + 1]
          if (data.some(d => new Date(d.date).getMonth() === now.getMonth())) {
            selectedMonth = currentMonthName
            document.getElementById("monthSelect").value = currentMonthName
          }
          
          // ends the loading screen
          filterAndRender()
          hideLoadingScreen()
          
        })

        // error for loading screen
        .catch(error => {
          console.error('Error fetching data:', error)
          // ALSO HIDE ON ERROR
          hideLoadingScreen()
          filterAndRender()
        })
        
    }
    
    /*
      Updates the time granularity (minute, hour, week, month),
      manages UI state for selectors, and re-renders the chart.
    */
    function changeGranularity(newGranularity) {
      granularity = newGranularity
      currentPeriodIndex = 0
      
      document.querySelectorAll('.time-toggle button').forEach(btn => btn.classList.remove('active'))
      document.getElementById(`btn-${newGranularity}`).classList.add('active')
      
      const daySelect = document.getElementById("daySelect")
      const hourSelect = document.getElementById("hourSelect")
      
      if (granularity === 'minute') {
        daySelect.style.display = 'inline-block'
        hourSelect.style.display = 'inline-block'
        if (selectedMonth !== "All Data") {
          populateDaySelector()
          if (selectedDay) {
            populateHourSelector()
          }
        }
      } else if (granularity === 'hour') {
        daySelect.style.display = 'inline-block'
        hourSelect.style.display = 'none'
        if (selectedMonth !== "All Data") {
          populateDaySelector()
        }
        selectedHour = null
      } else {
        daySelect.style.display = 'none'
        hourSelect.style.display = 'none'
        selectedDay = null
        selectedHour = null
      }
      
      filterAndRender()
    }


    /*
      Populates the day dropdown based on the selected month
      and auto-selects the most recent or current day if available.
    */
    function populateDaySelector() {
      const daySelect = document.getElementById("daySelect")
      daySelect.innerHTML = '<option value="">Select Day</option>'
      
      if (selectedMonth === "All Data") return
      
      const monthIndex = getMonthIndex(selectedMonth)
      const daysInMonth = data.filter(d => new Date(d.date).getMonth() === monthIndex)
      
      const uniqueDays = [...new Set(daysInMonth.map(d => d.displayDate))]
        .sort((a, b) => new Date(a) - new Date(b))
      
      uniqueDays.forEach(day => {
        const opt = document.createElement("option")
        opt.value = day
        opt.text = day
        daySelect.add(opt)
      })
      
      // Auto-select current day if it exists in the list
      if (!selectedDay && uniqueDays.length > 0) {
        const now = new Date()
        const currentDisplayDate = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
        if (uniqueDays.includes(currentDisplayDate)) {
          selectedDay = currentDisplayDate
          daySelect.value = currentDisplayDate
        } else {
          // Select the most recent day
          selectedDay = uniqueDays[uniqueDays.length - 1]
          daySelect.value = selectedDay
        }
      } else if (selectedDay) {
        daySelect.value = selectedDay
      }
    }

    /*
      Populates the hour dropdown for a selected day and
      auto-selects the most recent or current hour.
    */
    function populateHourSelector() {
      const hourSelect = document.getElementById("hourSelect")
      hourSelect.innerHTML = '<option value="">Select Hour</option>'
      
      if (!selectedDay) return
      
      const monthIndex = getMonthIndex(selectedMonth)
      const hoursInDay = data.filter(d => 
        new Date(d.date).getMonth() === monthIndex && d.displayDate === selectedDay
      )
      
      const uniqueHours = [...new Set(hoursInDay.map(d => d.hour))]
        .sort((a, b) => a - b)
      
      uniqueHours.forEach(hour => {
        const opt = document.createElement("option")
        opt.value = hour
        opt.text = `${hour.toString().padStart(2, '0')}:00`
        hourSelect.add(opt)
      })
      
      // Auto-select current hour if it exists in the list
      if (selectedHour === null && uniqueHours.length > 0) {
        const now = new Date()
        const currentHour = now.getHours()
        if (uniqueHours.includes(currentHour)) {
          selectedHour = currentHour
          hourSelect.value = currentHour
        } else {
          // Select the most recent hour
          selectedHour = uniqueHours[uniqueHours.length - 1]
          hourSelect.value = selectedHour
        }
      } else if (selectedHour !== null) {
        hourSelect.value = selectedHour
      }
    }

    /*
      Handles month selection changes and updates
      dependent day/hour selectors and chart state.
    */
    function handleChange() {
      selectedMonth = document.getElementById("monthSelect").value
      const daySelect = document.getElementById("daySelect")
      const hourSelect = document.getElementById("hourSelect")
      
      if (granularity === 'minute' || granularity === 'hour') {
        if (selectedMonth !== "All Data") {
          populateDaySelector()
          selectedDay = daySelect.value || null
          
          if (granularity === 'minute' && selectedDay) {
            populateHourSelector()
            selectedHour = hourSelect.value ? parseInt(hourSelect.value) : null
          }
        } else {
          selectedDay = null
          selectedHour = null
        }
      }
      
      currentPeriodIndex = 0
      filterAndRender()
    }

    /*
      Handles day selection changes and updates hour selector
      when in minute granularity.
    */
    function handleDayChange() {
      selectedDay = document.getElementById("daySelect").value || null
      
      if (granularity === 'minute' && selectedDay) {
        populateHourSelector()
        const hourSelect = document.getElementById("hourSelect")
        selectedHour = hourSelect.value ? parseInt(hourSelect.value) : null
      }
      
      filterAndRender()
    }

    /*
      Handles hour selection changes and triggers re-rendering.
    */
    function handleHourChange() {
      const hourSelect = document.getElementById("hourSelect")
      selectedHour = hourSelect.value ? parseInt(hourSelect.value) : null
      filterAndRender()
    }

    /*
      Converts a month name into a zero-based month index.
    */
    function getMonthIndex(month) {
      return months.indexOf(month) - 1
    }

    /*
      Aggregates raw data points into hourly totals.
    */
    // function aggregateByHour(dataToAggregate) {
    //   const hourlyData = {}
      
    //   dataToAggregate.forEach(d => {
    //     const key = d.hour
    //     if (!hourlyData[key]) {
    //       hourlyData[key] = {
    //         hour: d.hour,
    //         displayTime: `${d.hour.toString().padStart(2, '0')}`,
    //         left: 0,
    //         right: 0,
    //         count: 0,
    //         date: d.date,
    //         displayDate: d.displayDate
    //       }
    //     }
    //     hourlyData[key].left += d.left
    //     hourlyData[key].right += d.right
    //     hourlyData[key].count++
    //   })
      
    //   return Object.values(hourlyData).sort((a, b) => a.hour - b.hour)
    // }
    function aggregateByHour(dataToAggregate) {
      const hourlyData = {}
      
      // Initialize all 24 hours with 0
      for (let h = 0; h < 24; h++) {
        hourlyData[h] = {
          hour: h,
          displayTime: `${h.toString().padStart(2, '0')}`,
          left: 0,
          right: 0,
          count: 0,
          date: dataToAggregate.length > 0 ? dataToAggregate[0].date : '',
          displayDate: dataToAggregate.length > 0 ? dataToAggregate[0].displayDate : ''
        }
      }
      
      // Add actual data
      dataToAggregate.forEach(d => {
        const key = d.hour
        hourlyData[key].left += d.left
        hourlyData[key].right += d.right
        hourlyData[key].count++
      })
      
      return Object.values(hourlyData).sort((a, b) => a.hour - b.hour)
    }

   /*
      Ensures all 60 minutes (0-59) are present in the dataset,
      filling in missing minutes with zero values.
    */
    function fillAllMinutes(dataToFill, hour, displayDate, date) {
      const minuteData = {}
      
      // Initialize all 60 minutes with 0
      for (let m = 0; m < 60; m++) {
        minuteData[m] = {
          hour: hour,
          minute: m,
          displayDate: displayDate,
          date: date,
          displayTime: `${hour.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`,
          left: 0,
          right: 0
        }
      }
      
      // Add actual data
      dataToFill.forEach(d => {
        const key = d.minute
        minuteData[key].left = d.left
        minuteData[key].right = d.right
      })
      
      return Object.values(minuteData).sort((a, b) => a.minute - b.minute)
    }

    function aggregateByDay(dataToAggregate) {
      const dailyData = {}
      
      dataToAggregate.forEach(d => {
        const key = d.displayDate
        if (!dailyData[key]) {
          dailyData[key] = {
            displayDate: d.displayDate,
            date: d.date,
            left: 0,
            right: 0,
            count: 0
          }
        }
        dailyData[key].left += d.left
        dailyData[key].right += d.right
        dailyData[key].count++
      })
      
      return Object.values(dailyData).sort((a, b) => new Date(a.date) - new Date(b.date))
    }

    /*
      Splits daily data into sequential week-sized chunks.
    */
    function splitIntoWeeks(dataToSplit) {
      const sorted = [...dataToSplit].sort((a, b) => new Date(a.date) - new Date(b.date))
      return sorted.reduce((weeks, val, i) => {
        const weekIndex = Math.floor(i / 7)
        if (!weeks[weekIndex]) weeks[weekIndex] = []
        weeks[weekIndex].push(val)
        return weeks
      }, [])
    }

    /*
      Filters data based on selected month, day, hour, and granularity,
      updates navigation controls, and triggers chart rendering.
    */
    function filterAndRender() {
      let workingData = (selectedMonth === "All Data")
        ? data
        : data.filter(d => new Date(d.date).getMonth() === getMonthIndex(selectedMonth))

      const periodInfo = document.getElementById("periodInfo")
      const prevBtn = document.getElementById('prevBtn')
      const nextBtn = document.getElementById('nextBtn')

      if (!workingData.length) {
        filteredData = []
        periodInfo.textContent = ""
        prevBtn.style.display = 'none'
        nextBtn.style.display = 'none'
        renderChart()
        return
      }

      // Handle different granularities
      if (granularity === 'minute') {
        if (selectedDay && selectedHour !== null) {
          // Filter to specific day and hour, show all minutes (0-59)
          const rawMinuteData = workingData.filter(d => 
            d.displayDate === selectedDay && d.hour === selectedHour
          )
          
          // Fill in all 60 minutes, even if no data exists
          filteredData = fillAllMinutes(
            rawMinuteData, 
            selectedHour, 
            selectedDay, 
            rawMinuteData.length > 0 ? rawMinuteData[0].date : ''
          )
          
          periodInfo.textContent = `${selectedDay} ${selectedHour.toString().padStart(2, '0')}:00`
          prevBtn.style.display = 'none'
          nextBtn.style.display = 'none'
        } else {
          filteredData = []
          periodInfo.textContent = "Select month, day, and hour"
          prevBtn.style.display = 'none'
          nextBtn.style.display = 'none'
        }
      } else if (granularity === 'hour') {
        if (selectedDay) {
          // Filter to specific day, aggregate by hour
          const dayData = workingData.filter(d => d.displayDate === selectedDay)
          filteredData = aggregateByHour(dayData)
          
          periodInfo.textContent = selectedDay
          prevBtn.style.display = 'none'
          nextBtn.style.display = 'none'
        } else {
          filteredData = []
          periodInfo.textContent = "Select month and day"
          prevBtn.style.display = 'none'
          nextBtn.style.display = 'none'
        }
      } else if (granularity === 'week') {
        if (selectedMonth !== "All Data") {
          // Aggregate by day first, then split into weeks
          const dailyData = aggregateByDay(workingData)
          const weeks = splitIntoWeeks(dailyData)
          filteredData = weeks[currentPeriodIndex] || []
          
          periodInfo.textContent = `Week ${currentPeriodIndex + 1}`
          prevBtn.style.display = 'inline-block'
          nextBtn.style.display = 'inline-block'
          prevBtn.disabled = currentPeriodIndex === 0
          nextBtn.disabled = currentPeriodIndex === weeks.length - 1
        } else {
          filteredData = []
          periodInfo.textContent = "Select a month for week view"
          prevBtn.style.display = 'none'
          nextBtn.style.display = 'none'
        }
      } else { // month
        // Aggregate by day
        filteredData = aggregateByDay(workingData)
        periodInfo.textContent = selectedMonth !== "All Data" ? selectedMonth : ""
        prevBtn.style.display = 'none'
        nextBtn.style.display = 'none'
      }

      renderChart()
    }

    /*
      Renders or updates the Chart.js line chart based on filtered data
      and current granularity.
    */
    function renderChart() {
      const ctx = document.getElementById('lineChart').getContext('2d')

      if (lineChart) lineChart.destroy()

      if (!filteredData.length) {
        lineChart = new Chart(ctx, {
          type: 'line',
          data: { labels: [], datasets: [] },
          options: {
            plugins: { legend: { display: false }, tooltip: { enabled: false } },
            scales: { x: { display: false }, y: { display: false } },
            animation: false
          },
          plugins: [{
            id: 'noData',
            afterDraw(chart) {
              const { width, height } = chart
              const ctx = chart.ctx
              ctx.save()
              ctx.textAlign = 'center'
              ctx.textBaseline = 'middle'
              ctx.font = 'bold 18px sans-serif'
              ctx.fillStyle = 'gray'
              ctx.fillText('No data available - adjust filters above', width / 2, height / 2)
              ctx.restore()
            }
          }]
        })
        updateDataAnalysis()
        return
      }

      let labels, xAxisLabel
      
      if (granularity === 'minute') {
        labels = filteredData.map(d => `${d.hour.toString().padStart(2, '0')}:${d.minute.toString().padStart(2, '0')}`)
        xAxisLabel = 'Time (Minutes)'
      } else if (granularity === 'hour') {
        labels = filteredData.map(d => d.displayTime)
        xAxisLabel = 'Time (Hours)'
      } else if (granularity === 'week') {
        labels = filteredData.map(d => d.displayDate)
        xAxisLabel = 'Days in Week'
      } else {
        labels = filteredData.map(d => d.displayDate)
        xAxisLabel = 'Days in Month'
      }

      const chartData = {
        labels,
        datasets: [
          {
            label: 'Left', 
            data: filteredData.map(d => d.left),
            borderColor: 'blue',
            backgroundColor: 'blue',
            borderWidth: 7,
            tension: 0.4,
            pointRadius: 3
          },
          {
            label: 'Right',
            data: filteredData.map(d => d.right),
            borderColor: 'red',
            backgroundColor: 'red',
            borderWidth: 7,
            tension: 0.4,
            pointRadius: 3
          }
        ]
      }
      
      lineChart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            tooltip: { enabled: false, external: customTooltip },
            legend: { labels: { color: 'black', font: { size: 18, weight: 'bold' } } }
          },
          hover: { mode: 'index', intersect: false },
          scales: {
            x: {
              grid: { display: true, color: 'rgba(255, 255, 255, 0.1)' },
              ticks: { color: 'black', font: { size: 25, weight: 'bold' }, maxRotation: 45, minRotation: 45, autoskip: false, maxTicksLimit: granularity === 'minute' ? 60 : undefined },
              title: { display: true, text: xAxisLabel, color: 'black', font: { size: 25, weight: 'bold' } }
            },
            y: {
              grid: { display: true, color: 'rgba(0, 0, 0, 0.1)' },
              ticks: { color: 'black' , font: { size: 25, weight: 'bold' }, },
              title: { display: true, text: 'People Count', color: 'black', font: { size: 25, weight: 'bold' } }
            }
          }
        },
        plugins: [{
          id: 'hoverLine',
          afterDraw(chart) {
            if (chart.tooltip?._active?.length) {
              const ctx = chart.ctx
              const x = chart.tooltip._active[0].element.x
              const topY = chart.scales.y.top
              const bottomY = chart.scales.y.bottom
              ctx.save()
              ctx.beginPath()
              ctx.moveTo(x, topY)
              ctx.lineTo(x, bottomY)
              ctx.lineWidth = 2
              ctx.strokeStyle = 'gray'
              ctx.stroke()
              ctx.restore()
            }
          }
        }]
      })
    }

    /*
      Updates the summary statistics panel shown below the chart.
    */
    function updateDataAnalysis() {
      const tooltipEl = document.getElementById('custom-tooltip')
      
      if (!filteredData.length) {
        tooltipEl.innerHTML = `
          <div style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center; font-size: 25px; color: black;">
            <span style="background: #e3f2fd; padding: 8px 16px; border-radius: 20px; font-weight: bold;">Data Analysis</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Date:</strong> --</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Left:</strong> --</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Right:</strong> --</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Total Left:</strong> --</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Total Right:</strong> --</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Peak:</strong> --</span>
            <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Average:</strong> --</span>
          </div>
        `
        return
      }

      const sortedData = [...filteredData].sort((a, b) => {
        if (granularity === 'minute') return b.minute - a.minute
        if (granularity === 'hour') return b.hour - a.hour
        return new Date(b.date) - new Date(a.date)
      })
      const currentPoint = sortedData[0]
      
      const totalLeft = filteredData.reduce((sum, d) => sum + d.left, 0)
      const totalRight = filteredData.reduce((sum, d) => sum + d.right, 0)
      const avg = Math.round((totalLeft + totalRight) / filteredData.length)
      const peak = filteredData.reduce((a, b) => (a.left + a.right > b.left + b.right ? a : b))
      
      let displayLabel = currentPoint.displayDate || '--'
      if (granularity === 'minute') {
        displayLabel = `${currentPoint.displayDate} ${currentPoint.hour.toString().padStart(2, '0')}:${currentPoint.minute.toString().padStart(2, '0')}`
      } else if (granularity === 'hour') {
        displayLabel = `${currentPoint.displayDate} ${currentPoint.displayTime}`
      }
      
      let peakLabel = peak.displayDate || '--'
      if (granularity === 'minute' && peak.minute !== undefined) {
        peakLabel = `${peak.hour.toString().padStart(2, '0')}:${peak.minute.toString().padStart(2, '0')}`
      } else if (granularity === 'hour' && peak.displayTime) {
        peakLabel = peak.displayTime
      }

      tooltipEl.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center; font-size: 25px; font-weight: bold; color: black;">
          <span style="background: #e3f2fd; padding: 8px 16px; border-radius: 20px; font-weight: bold;">Data Analysis</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Time:</strong> ${displayLabel}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Left:</strong> ${currentPoint.left}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Right:</strong> ${currentPoint.right}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Total Left:</strong> ${totalLeft}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Total Right:</strong> ${totalRight}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Peak:</strong> ${peakLabel}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Average:</strong> ${avg}</span>
        </div>
      `
    }

    function customTooltip(ctx) {
      const index = ctx.tooltip.dataPoints?.[0]?.dataIndex
      if (index == null || !filteredData.length) return

      const point = filteredData[index]
      const totalLeft = filteredData.reduce((sum, d) => sum + d.left, 0)
      const totalRight = filteredData.reduce((sum, d) => sum + d.right, 0)
      const avg = Math.round((totalLeft + totalRight) / filteredData.length)
      const peak = filteredData.reduce((a, b) => (a.left + a.right > b.left + b.right ? a : b))
      
      let displayLabel = point.displayDate || '--'
      if (granularity === 'minute') {
        displayLabel = `${point.displayDate} ${point.hour.toString().padStart(2, '0')}:${point.minute.toString().padStart(2, '0')}`
      } else if (granularity === 'hour') {
        displayLabel = `${point.displayDate} ${point.displayTime}`
      }
      
      let peakLabel = peak.displayDate || '--'
      if (granularity === 'minute' && peak.minute !== undefined) {
        peakLabel = `${peak.hour.toString().padStart(2, '0')}:${peak.minute.toString().padStart(2, '0')}`
      } else if (granularity === 'hour' && peak.displayTime) {
        peakLabel = peak.displayTime
      }

      const tooltipEl = document.getElementById('custom-tooltip')
      tooltipEl.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center; font-size: 25px; font-weight: bold; color: black;">
          <span style="background: #e3f2fd; padding: 8px 16px; border-radius: 20px; font-weight: bold;">Data Analysis</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Time:</strong> ${displayLabel}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Left:</strong> ${point.left}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Right:</strong> ${point.right}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Total Left:</strong> ${totalLeft}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Total Right:</strong> ${totalRight}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Peak:</strong> ${peakLabel}</span>
          <span style="background: white; padding: 8px 16px; border-radius: 20px; border: 2px solid #e0e0e0;"><strong>Average:</strong> ${avg}</span>
        </div>
      `
    }

    /*
      Navigates to the previous week when in week view.
    */
    function prevPeriod() {
      if (currentPeriodIndex > 0) {
        currentPeriodIndex--
        filterAndRender()
      }
    }

    /*
      Navigates to the next week when in week view.
    */
    function nextPeriod() {
      currentPeriodIndex++
      filterAndRender()
    }
  </script>
</body>
</html>